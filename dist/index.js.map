{"version":3,"sources":["../src/index.ts","../src/bindings.ts","../src/GlobalEffectRuntime.ts","../src/inspect.ts","../src/repository.ts"],"sourcesContent":["export { \n  EffectRuntimeProvider, \n  makeAppRuntime, \n  runForkEffect, \n  useEffectStream, \n  useProgram, \n  useRuntime, \n  useSubscription\n} from './bindings';\n\nexport { makeInspectInstance } from './inspect';\nexport { makeRepository } from './repository'; \n\n","/* eslint-disable no-param-reassign */\n/* eslint-disable no-redeclare */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  Context,\n  Effect,\n  Exit,\n  Fiber,\n  Layer,\n  pipe, \n  Runtime,\n  Scope,\n  Stream,\n} from 'effect';\nimport {\n  createContext,\n  MutableRefObject,\n  useContext,\n  useEffect,\n  useRef,\n  useSyncExternalStore,\n} from 'react'; \n\nimport { GlobalEffectRuntime } from './GlobalEffectRuntime';\nimport { BaseImplementation } from './repository';\nimport { StreamEffect } from './types';\n\nconst globalRuntime = new GlobalEffectRuntime();\n\nexport const runForkEffect = (program: Effect.Effect<void, any, any>) => {\n  globalRuntime.addForkProgram(program);\n};\n\nexport const makeAppRuntime = <A, E, R>(layer: Layer.Layer<A, E, R>) =>\n  Effect.gen(function* ($) {\n    const scope = yield* $(Scope.make());\n    const context: Context.Context<A> = yield* $(\n      Layer.buildWithScope(scope)(layer),\n    );\n    const runtime = yield* $(\n      pipe(Effect.runtime<A>(), Effect.provide(context)),\n    );\n\n    globalRuntime.initRuntime(runtime);\n\n    return {\n      runtime,\n      close: Scope.close(scope, Exit.unit),\n    };\n  });\n\nexport const EffectRuntimeProvider = createContext<Runtime.Runtime<any>>(\n  Runtime.defaultRuntime as any,\n);\n\nexport const useRuntime = () => useContext(EffectRuntimeProvider);\n\nexport const useProgram = <A, E, R>(program: Effect.Effect<A, E, R>) => {\n  const runtime = useRuntime();\n  useEffect(() => {\n    if (runtime) {\n      const fiber = Runtime.runFork(runtime)(program);\n      return () => {\n        Effect.runPromise(Fiber.interrupt(fiber));\n      };\n    }\n    return undefined;\n  }, [runtime]);\n};\n\nconst makeSubscribeTag =\n  <A, B>(\n    tag: Context.Tag<any, BaseImplementation<A>>,\n    runtime: Runtime.Runtime<unknown>,\n    selectorFn?: (store: A) => B,\n  ) =>\n    (onChange: () => void) => {\n      const fib = Effect.flatMap(tag, ref =>\n        pipe(\n          ref.changes,\n          Stream.map(store => (selectorFn ? selectorFn(store) : store)),\n          Stream.changes,\n          Stream.tap(() => Effect.sync(onChange)),\n          Stream.runDrain,\n        ),\n      );\n      const fiber = Runtime.runFork(runtime)(fib);\n      return () => {\n        return Effect.runPromise(Fiber.interrupt(fiber));\n      };\n    };\n\nconst makeSubscribeEffect =\n  <A>(\n    program: StreamEffect<A>,\n    runtime: Runtime.Runtime<unknown>,\n    ref: MutableRefObject<A | undefined>,\n  ) =>\n    (onChange: () => void) => {\n      const fib = Effect.flatMap(program, stream$ =>\n        pipe(\n          stream$,\n          Stream.changes,\n          Stream.tap(data =>\n            Effect.sync(() => {\n              ref.current = data;\n              onChange();\n            }),\n          ),\n          Stream.runDrain,\n        ),\n      );\n      const fiber = Runtime.runFork(runtime)(fib);\n      return () => {\n        return Effect.runPromise(Fiber.interrupt(fiber));\n      };\n    };\n\nexport function useSubscription<StoreType>(\n  contextRef: Context.Tag<any, BaseImplementation<StoreType>>,\n): StoreType;\nexport function useSubscription<StoreType, SelectorFnType>(\n  contextRef: Context.Tag<any, BaseImplementation<StoreType>>,\n  selectorFn: (store: StoreType) => SelectorFnType,\n): SelectorFnType;\nexport function useSubscription<StoreType, SelectorFnType>(\n  contextRef: Context.Tag<any, BaseImplementation<StoreType>>,\n  selectorFn?: (store: StoreType) => SelectorFnType,\n) {\n  const runtime = useRuntime();\n  const subscribe = useRef<(db: () => void) => () => void>();\n  if (!subscribe.current && runtime) {\n    subscribe.current = makeSubscribeTag(contextRef, runtime, selectorFn);\n  }\n\n  return useSyncExternalStore(subscribe.current as any, () => {\n    const program = pipe(\n      Effect.flatMap(contextRef, service => service.get()),\n      Effect.map(store => (selectorFn ? selectorFn(store) : store)),\n    );\n    return Runtime.runSync(runtime)(program);\n  });\n}\n\nexport function useEffectStream<StoreType>(program: StreamEffect<StoreType>) {\n  const runtime = useRuntime();\n  const subscribe = useRef<(db: () => void) => () => void>();\n\n  const refData = useRef<StoreType>();\n  if (!subscribe.current && runtime) {\n    subscribe.current = makeSubscribeEffect(program, runtime, refData);\n  }\n\n  return useSyncExternalStore(subscribe.current as any, () => {\n    return refData.current;\n  });\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Effect, Runtime } from 'effect';\n\nexport class GlobalEffectRuntime {\n  runtime: Runtime.Runtime<any> | null = null;\n\n  programs: Effect.Effect<void, any, any>[] = [];\n\n  addForkProgram(program: Effect.Effect<void, any, any>) {\n    this.programs.push(program);\n    this.runFork();\n  } \n\n  runFork() { \n    if (!this.runtime) {\n      return;\n    }\n\n    Runtime.runFork(this.runtime)(\n      Effect.all(this.programs, { concurrency: 'unbounded' }),\n    );\n\n    this.programs = [];\n  }\n\n  initRuntime(runtime: Runtime.Runtime<any>) {\n    this.runtime = runtime;\n    this.runFork();\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable require-yield */\nimport { Context, Effect, Option, Stream, flow } from 'effect';\nimport { assocPath, mergeDeepRight } from 'ramda';\n\nimport { BaseImplementation } from './repository';\nimport { StreamEffect } from './types';\n\n\n\n\nconst initExtension = (name: string, isDev = true) => \n  Option.gen(function* ($) {\n        \n    if (!isDev) {\n      return yield* $(Option.none());\n    }\n    const extension = yield* $(\n      Option.fromNullable(window.__REDUX_DEVTOOLS_EXTENSION__),\n    );\n\n    const instance = extension.connect({ name });\n\n    return yield* $(Option.some(instance)); \n  });\n\nclass InstanceStore {\n  store: Store = {};\n\n  get() {\n    return this.store;\n  }\n\n  update(data: Record<string, unknown>) {\n    this.store = mergeDeepRight(this.store, data);\n    return this.store;\n  }\n}\n\nexport const makeInspectInstance = (name: string) => {\n  const _instance = initExtension(name);\n  const store = new InstanceStore();\n\n  const makeStream =\n    (defaultName?: string) =>\n      (value: Context.Tag<any, BaseImplementation<any>> | StreamEffect<any>) => {\n        const sendToDevtools = (currentName: string) =>\n          Stream.tap(data =>\n            Effect.tap(_instance, instance => {\n              const logObject = assocPath(currentName.split('/'), data, {});\n              const result = store.update(logObject);\n\n              instance.send(currentName, result);\n            }),\n          );\n        if (Context.isTag(value)) {\n          return Effect.flatMap(value, ref => {\n            return ref.changes.pipe(sendToDevtools(value.key), Stream.runDrain);\n          });\n        }\n\n        if (Effect.isEffect(value)) {\n          return value.pipe(\n            Effect.flatMap(\n              flow(sendToDevtools(`${defaultName}/combined$`), Stream.runDrain),\n            ),\n          );\n        }\n\n        return Effect.succeed(0);\n      };\n\n  const makeInspectorEffectProgram = (\n    stores: ({ Live: Context.Tag<any, BaseImplementation<any>>} | StreamEffect<any>)[],\n    defaultName?: string,\n  ) => {\n    return Effect.gen(function* ($) {\n      if (Option.isNone(_instance)) {\n        return;\n      }\n\n      const streams$ = stores.map(x => {\n        if ('Live' in x) {\n          return x.Live;\n        }\n        return x;\n      })\n        .map(makeStream(defaultName));\n\n      yield* $(Effect.all(streams$, { concurrency: 'unbounded' }));\n    });\n  };\n\n  return { makeInspectorEffectProgram };\n};\n\n\n\ntype ReduxDevTools = {\n  connect: (params: { name: string }) => {\n    send: (type: string, value: Record<string, unknown>) => void;\n  };\n};\ninterface MyWindow extends Window {\n  __REDUX_DEVTOOLS_EXTENSION__?: ReduxDevTools;\n\n}\n\ndeclare let window: MyWindow;\n\ntype Store = Record<string, unknown>;","import { Context, Effect, Layer, Stream, SubscriptionRef } from 'effect';\n\ninterface Tag {\n  readonly _: unique symbol;\n}\n\nexport const makeRepository = <RepositoryType>(\n  name: string,\n  defaultValue: RepositoryType,\n) => {\n\n  const Tag = Context.GenericTag<Tag, BaseImplementation<RepositoryType>>(name);\n\n  const Live = Layer.scoped(\n    Tag,\n    Effect.gen(function* ($) {\n      const ref = yield* $(SubscriptionRef.make(defaultValue));\n\n      return {\n        changes: ref.changes,\n        update: fn => SubscriptionRef.update(ref, fn),\n        get: () => SubscriptionRef.get(ref),\n      };\n    }), \n  );\n\n  return { Tag, Live };\n};\n\nexport interface BaseImplementation<RepositoryType> {\n  changes: Stream.Stream<RepositoryType, never, never>;\n  get: () => Effect.Effect<RepositoryType, never, never>;\n  update: (\n    fn: (store: RepositoryType) => RepositoryType,\n  ) => Effect.Effect<void, never, never>;\n}\n"],"mappings":"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","names":["import_effect","import_effect","import_effect"]}