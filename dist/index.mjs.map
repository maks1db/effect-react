{"version":3,"sources":["../src/bindings.ts","../src/GlobalEffectRuntime.ts","../src/inspect.ts","../src/repository.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\n/* eslint-disable no-redeclare */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n  Context,\n  Effect,\n  Exit,\n  Fiber,\n  Layer,\n  pipe, \n  Runtime,\n  Scope,\n  Stream,\n} from 'effect';\nimport {\n  createContext,\n  MutableRefObject,\n  useContext,\n  useEffect,\n  useRef,\n  useSyncExternalStore,\n} from 'react'; \n\nimport { GlobalEffectRuntime } from './GlobalEffectRuntime';\nimport { BaseImplementation } from './repository';\nimport { StreamEffect } from './types';\n\nconst globalRuntime = new GlobalEffectRuntime();\n\nexport const runForkEffect = (program: Effect.Effect<void, any, any>) => {\n  globalRuntime.addForkProgram(program);\n};\n\nexport const makeAppRuntime = <A, E, R>(layer: Layer.Layer<A, E, R>) =>\n  Effect.gen(function* ($) {\n    const scope = yield* $(Scope.make());\n    const context: Context.Context<A> = yield* $(\n      Layer.buildWithScope(scope)(layer),\n    );\n    const runtime = yield* $(\n      pipe(Effect.runtime<A>(), Effect.provide(context)),\n    );\n\n    globalRuntime.initRuntime(runtime);\n\n    return {\n      runtime,\n      close: Scope.close(scope, Exit.unit),\n    };\n  });\n\nexport const EffectRuntimeProvider = createContext<Runtime.Runtime<any>>(\n  Runtime.defaultRuntime as any,\n);\n\nexport const useRuntime = () => useContext(EffectRuntimeProvider);\n\nexport const useProgram = <A, E, R>(program: Effect.Effect<A, E, R>) => {\n  const runtime = useRuntime();\n  useEffect(() => {\n    if (runtime) {\n      const fiber = Runtime.runFork(runtime)(program);\n      return () => {\n        Effect.runPromise(Fiber.interrupt(fiber));\n      };\n    }\n    return undefined;\n  }, [runtime]);\n};\n\nconst makeSubscribeTag =\n  <A, B>(\n    tag: Context.Tag<any, BaseImplementation<A>>,\n    runtime: Runtime.Runtime<unknown>,\n    selectorFn?: (store: A) => B,\n  ) =>\n    (onChange: () => void) => {\n      const fib = Effect.flatMap(tag, ref =>\n        pipe(\n          ref.changes,\n          Stream.map(store => (selectorFn ? selectorFn(store) : store)),\n          Stream.changes,\n          Stream.tap(() => Effect.sync(onChange)),\n          Stream.runDrain,\n        ),\n      );\n      const fiber = Runtime.runFork(runtime)(fib);\n      return () => {\n        return Effect.runPromise(Fiber.interrupt(fiber));\n      };\n    };\n\nconst makeSubscribeEffect =\n  <A>(\n    program: StreamEffect<A>,\n    runtime: Runtime.Runtime<unknown>,\n    ref: MutableRefObject<A | undefined>,\n  ) =>\n    (onChange: () => void) => {\n      const fib = Effect.flatMap(program, stream$ =>\n        pipe(\n          stream$,\n          Stream.changes,\n          Stream.tap(data =>\n            Effect.sync(() => {\n              ref.current = data;\n              onChange();\n            }),\n          ),\n          Stream.runDrain,\n        ),\n      );\n      const fiber = Runtime.runFork(runtime)(fib);\n      return () => {\n        return Effect.runPromise(Fiber.interrupt(fiber));\n      };\n    };\n\nexport function useSubscription<StoreType>(\n  contextRef: Context.Tag<any, BaseImplementation<StoreType>>,\n): StoreType;\nexport function useSubscription<StoreType, SelectorFnType>(\n  contextRef: Context.Tag<any, BaseImplementation<StoreType>>,\n  selectorFn: (store: StoreType) => SelectorFnType,\n): SelectorFnType;\nexport function useSubscription<StoreType, SelectorFnType>(\n  contextRef: Context.Tag<any, BaseImplementation<StoreType>>,\n  selectorFn?: (store: StoreType) => SelectorFnType,\n) {\n  const runtime = useRuntime();\n  const subscribe = useRef<(db: () => void) => () => void>();\n  if (!subscribe.current && runtime) {\n    subscribe.current = makeSubscribeTag(contextRef, runtime, selectorFn);\n  }\n\n  return useSyncExternalStore(subscribe.current as any, () => {\n    const program = pipe(\n      Effect.flatMap(contextRef, service => service.get()),\n      Effect.map(store => (selectorFn ? selectorFn(store) : store)),\n    );\n    return Runtime.runSync(runtime)(program);\n  });\n}\n\nexport function useEffectStream<StoreType>(program: StreamEffect<StoreType>) {\n  const runtime = useRuntime();\n  const subscribe = useRef<(db: () => void) => () => void>();\n\n  const refData = useRef<StoreType>();\n  if (!subscribe.current && runtime) {\n    subscribe.current = makeSubscribeEffect(program, runtime, refData);\n  }\n\n  return useSyncExternalStore(subscribe.current as any, () => {\n    return refData.current;\n  });\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Effect, Runtime } from 'effect';\n\nexport class GlobalEffectRuntime {\n  runtime: Runtime.Runtime<any> | null = null;\n\n  programs: Effect.Effect<void, any, any>[] = [];\n\n  addForkProgram(program: Effect.Effect<void, any, any>) {\n    this.programs.push(program);\n    this.runFork();\n  } \n\n  runFork() { \n    if (!this.runtime) {\n      return;\n    }\n\n    Runtime.runFork(this.runtime)(\n      Effect.all(this.programs, { concurrency: 'unbounded' }),\n    );\n\n    this.programs = [];\n  }\n\n  initRuntime(runtime: Runtime.Runtime<any>) {\n    this.runtime = runtime;\n    this.runFork();\n  }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable require-yield */\nimport { Context, Effect, Option, Stream, flow } from 'effect';\nimport { assocPath, mergeDeepRight } from 'ramda';\n\nimport { BaseImplementation } from './repository';\nimport { StreamEffect } from './types';\n\n\n\n\nconst initExtension = (name: string, isDev = true) => \n  Option.gen(function* ($) {\n        \n    if (!isDev) {\n      return yield* $(Option.none());\n    }\n    const extension = yield* $(\n      Option.fromNullable(window.__REDUX_DEVTOOLS_EXTENSION__),\n    );\n\n    const instance = extension.connect({ name });\n\n    return yield* $(Option.some(instance)); \n  });\n\nclass InstanceStore {\n  store: Store = {};\n\n  get() {\n    return this.store;\n  }\n\n  update(data: Record<string, unknown>) {\n    this.store = mergeDeepRight(this.store, data);\n    return this.store;\n  }\n}\n\nexport const makeInspectInstance = (name: string) => {\n  const _instance = initExtension(name);\n  const store = new InstanceStore();\n\n  const makeStream =\n    (defaultName?: string) =>\n      (value: Context.Tag<any, BaseImplementation<any>> | StreamEffect<any>) => {\n        const sendToDevtools = (currentName: string) =>\n          Stream.tap(data =>\n            Effect.tap(_instance, instance => {\n              const logObject = assocPath(currentName.split('/'), data, {});\n              const result = store.update(logObject);\n\n              instance.send(currentName, result);\n            }),\n          );\n        if (Context.isTag(value)) {\n          return Effect.flatMap(value, ref => {\n            return ref.changes.pipe(sendToDevtools(value.key), Stream.runDrain);\n          });\n        }\n\n        if (Effect.isEffect(value)) {\n          return value.pipe(\n            Effect.flatMap(\n              flow(sendToDevtools(`${defaultName}/combined$`), Stream.runDrain),\n            ),\n          );\n        }\n\n        return Effect.succeed(0);\n      };\n\n  const makeInspectorEffectProgram = (\n    stores: ({ Live: Context.Tag<any, BaseImplementation<any>>} | StreamEffect<any>)[],\n    defaultName?: string,\n  ) => {\n    return Effect.gen(function* ($) {\n      if (Option.isNone(_instance)) {\n        return;\n      }\n\n      const streams$ = stores.map(x => {\n        if ('Live' in x) {\n          return x.Live;\n        }\n        return x;\n      })\n        .map(makeStream(defaultName));\n\n      yield* $(Effect.all(streams$, { concurrency: 'unbounded' }));\n    });\n  };\n\n  return { makeInspectorEffectProgram };\n};\n\n\n\ntype ReduxDevTools = {\n  connect: (params: { name: string }) => {\n    send: (type: string, value: Record<string, unknown>) => void;\n  };\n};\ninterface MyWindow extends Window {\n  __REDUX_DEVTOOLS_EXTENSION__?: ReduxDevTools;\n\n}\n\ndeclare let window: MyWindow;\n\ntype Store = Record<string, unknown>;","import { Context, Effect, Layer, Stream, SubscriptionRef } from 'effect';\n\ninterface Tag {\n  readonly _: unique symbol;\n}\n\nexport const makeRepository = <RepositoryType>(\n  name: string,\n  defaultValue: RepositoryType,\n) => {\n\n  const Tag = Context.GenericTag<Tag, BaseImplementation<RepositoryType>>(name);\n\n  const Live = Layer.scoped(\n    Tag,\n    Effect.gen(function* ($) {\n      const ref = yield* $(SubscriptionRef.make(defaultValue));\n\n      return {\n        changes: ref.changes,\n        update: fn => SubscriptionRef.update(ref, fn),\n        get: () => SubscriptionRef.get(ref),\n      };\n    }), \n  );\n\n  return { Tag, Live };\n};\n\nexport interface BaseImplementation<RepositoryType> {\n  changes: Stream.Stream<RepositoryType, never, never>;\n  get: () => Effect.Effect<RepositoryType, never, never>;\n  update: (\n    fn: (store: RepositoryType) => RepositoryType,\n  ) => Effect.Effect<void, never, never>;\n}\n"],"mappings":"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","names":["Effect","Runtime","Effect","Runtime","Context","Effect","Stream","Stream","Effect","Context","Context","Effect","Layer","Context","Layer","Effect"]}